
JSONPath: Query Expressions for JSON (RFC 9535)

JSONPath defines a string syntax for selecting and extracting JSON values from within a given JSON value.

Contents:
1. Introduction and Terminology
2. JSONPath Syntax and Semantics
   - Root Identifier ($)
   - Selectors (name, wildcard, index, slice, filter)
   - Function Extensions
   - Segments (child, descendant)
Appendix: ABNF Grammar

1.  Introduction

JSONPath defines a string syntax for selecting and extracting JSON values from within a given JSON value. It's a more powerful companion to JSON Pointer.

1.1.  Terminology

Key Terms:
- Value: JSON primitive (number, string, true, false, null) or structured (object, array) data
- Member: Name/value pair in an object
- Element: A value in an array  
- Index: Integer identifying array element
- Query: JSONPath expression
- Query Argument: The JSON value being queried
- Node: Value + its location within query argument
- Root Node: Node whose value is the entire query argument
- Children: For arrays - element nodes; for objects - member value nodes
- Descendants: Children + their children recursively
- Nodelist: List of nodes (query result)
- Selector: Produces child nodes from input value
- Segment: Selects children ([selectors]) or descendants (..[selectors])
- Singular Query: Expression producing at most one node

Identifiers:
- Root Node Identifier ($): References root node
- Current Node Identifier (@): References current node in filter expressions

This document treats the query argument as a tree of nodes. Each node is either the root or one of its descendants. Query results are nodelists.

1.2.  JSONPath Overview

JSONPath expressions consist of an identifier ($) followed by zero or more segments. Each segment contains one or more selectors.

Syntax Forms:
- Bracket notation: $['store']['book'][0]['title'] 
- Dot notation: $.store.book[0].title (shorthand)

Expression Structure:
- Identifiers: $ (root), @ (current node in filters)
- Segments: [selectors] (children), ..[selectors] (descendants)  
- Selectors: name, wildcard (*), index, slice, filter

JSONPath Syntax Reference:

| Syntax Element   | Description                          |
|------------------|--------------------------------------|
| $                | root node identifier                |
| @                | current node identifier (filters)   |
| [selectors]      | child segment                        |
| .name            | shorthand for ['name']               |
| .*               | shorthand for [*]                    |
| ..[selectors]    | descendant segment                   |
| ..name           | shorthand for ..['name']             |
| ..*              | shorthand for ..[*]                  |
| 'name'           | name selector                        |
| *                | wildcard selector                    |
| 3                | index selector (0-based)             |
| 0:100:5          | array slice start:end:step           |
| ?<logical-expr>  | filter selector                      |
| length(@.foo)    | function extension                   |

                    Table 1: Overview of JSONPath Syntax

1.5.  JSONPath Examples

Example JSON (bookstore):
{
  "store": {
    "book": [
      {"category": "reference", "author": "Nigel Rees", "title": "Sayings of the Century", "price": 8.95},
      {"category": "fiction", "author": "Evelyn Waugh", "title": "Sword of Honour", "price": 12.99},
      {"category": "fiction", "author": "Herman Melville", "title": "Moby Dick", "isbn": "0-553-21311-3", "price": 8.99},
      {"category": "fiction", "author": "J. R. R. Tolkien", "title": "The Lord of the Rings", "isbn": "0-395-19395-8", "price": 22.99}
    ],
    "bicycle": {"color": "red", "price": 399}
  }
}

    +========================+=======================================+
    | JSONPath               | Intended Result                       |
    +========================+=======================================+
    | $.store.book[*].author | the authors of all books in the store |
    +------------------------+---------------------------------------+
    | $..author              | all authors                           |
    +------------------------+---------------------------------------+
    | $.store.*              | all things in the store, which are    |
    |                        | some books and a red bicycle          |
    +------------------------+---------------------------------------+
    | $.store..price         | the prices of everything in the store |
    +------------------------+---------------------------------------+
    | $..book[2]             | the third book                        |
    +------------------------+---------------------------------------+
    | $..book[2].author      | the third book's author               |
    +------------------------+---------------------------------------+
    | $..book[2].publisher   | empty result: the third book does not |
    |                        | have a "publisher" member             |
    +------------------------+---------------------------------------+
    | $..book[-1]            | the last book in order                |
    +------------------------+---------------------------------------+
    | $..book[0,1]           | the first two books                   |
    | $..book[:2]            |                                       |
    +------------------------+---------------------------------------+
    | $..book[?@.isbn]       | all books with an ISBN number         |
    +------------------------+---------------------------------------+
    | $..book[?@.price<10]   | all books cheaper than 10             |
    +------------------------+---------------------------------------+
    | $..*                   | all member values and array elements  |
    |                        | contained in the input value          |
    +------------------------+---------------------------------------+

         Table 2: Example JSONPath Expressions and Their Intended
              Results When Applied to the Example JSON Value

2.  JSONPath Syntax and Semantics

2.1.  Overview

   A JSONPath _expression_ is a string that, when applied to a JSON
   value (the _query argument_), selects zero or more nodes of the
   argument and outputs these nodes as a nodelist.

   A query MUST be encoded using UTF-8.  The grammar for queries given
   in this document assumes that its UTF-8 form is first decoded into
   Unicode scalar values as described in [RFC3629]; implementation
   approaches that lead to an equivalent result are possible.

   A string to be used as a JSONPath query needs to be _well-formed_ and
   _valid_. A string is a well-formed JSONPath query if it conforms to
   the ABNF syntax in this document.  A well-formed JSONPath query is
   valid if it also fulfills both semantic requirements posed by this
   document, which are as follows:

   1.  Integer numbers in the JSONPath query that are relevant to the
       JSONPath processing (e.g., index values and steps) MUST be within
       the range of exact integer values defined in Internet JSON
       (I-JSON) (see Section 2.2 of [RFC7493]), namely within the
       interval [-(2^53)+1, (2^53)-1].

   2.  Uses of function extensions MUST be _well-typed_, as described in
       Section 2.4.3.

   A JSONPath implementation MUST raise an error for any query that is
   not well-formed and valid.  The well-formedness and the validity of
   JSONPath queries are independent of the JSON value the query is
   applied to.  No further errors relating to the well-formedness and
   the validity of a JSONPath query can be raised during application of
   the query to a value.  This clearly separates well-formedness/
   validity errors in the query from mismatches that may actually stem
   from flaws in the data.

   Mismatches between the structure expected by a valid query and the
   structure found in the data can lead to empty query results, which
   may be unexpected and indicate bugs in either.  JSONPath
   implementations might therefore want to provide diagnostics to the
   application developer that aid in finding the cause of empty results.

   Obviously, an implementation can still fail when executing a JSONPath
   query, e.g., because of resource depletion, but this is not modeled
   in this document.  However, the implementation MUST NOT silently
   malfunction.  Specifically, if a valid JSONPath query is evaluated
   against a structured value whose size is too large to process the
   query correctly (for instance, requiring the processing of numbers
   that fall outside the range of exact values), the implementation MUST
   provide an indication of overflow.

   (Readers familiar with the HTTP error model may be reminded of 400
   type errors when pondering well-formedness and validity, and they may
   recognize resource depletion and related errors as comparable to 500
   type errors.)

2.1.1.  Syntax

   Syntactically, a JSONPath query consists of a root identifier ($),
   which stands for a nodelist that contains the root node of the query
   argument, followed by a possibly empty sequence of _segments_.

   jsonpath-query      = root-identifier segments
   segments            = *(S segment)

   B                   = %x20 /    ; Space
                         %x09 /    ; Horizontal tab
                         %x0A /    ; Line feed or New line
                         %x0D      ; Carriage return
   S                   = *B        ; optional blank space

   The syntax and semantics of segments are defined in Section 2.5.

Execution Semantics:
1. Query execution starts with root identifier ($) producing root node
2. Each segment processes input nodelist and produces output nodelist  
3. Segments are applied sequentially: root ‚Üí segment1 ‚Üí segment2 ‚Üí ...
4. Final result is concatenated nodelist from last segment
5. Empty results are valid; duplicates are preserved
6. Implementations must produce identical results but can use any algorithm

2.1.3.  Example

   Consider this example.  With the query argument
   {"a":[{"b":0},{"b":1},{"c":2}]}, the query $.a[*].b selects the
   following list of nodes (denoted here by their values): 0, 1.

   The query consists of $ followed by three segments: .a, [*], and .b.

   First, $ produces a nodelist consisting of just the query argument.

   Next, .a selects from any object input node and selects the node of
   any member value of the input node corresponding to the member name
   "a".  The result is again a list containing a single node:
   [{"b":0},{"b":1},{"c":2}].

   Next, [*] selects all the elements from the input array node.  The
   result is a list of three nodes: {"b":0}, {"b":1}, and {"c":2}.

   Finally, .b selects from any object input node with a member name b
   and selects the node of the member value of the input node
   corresponding to that name.  The result is a list containing 0, 1.
   This is the concatenation of three lists: two of length one
   containing 0, 1, respectively, and one of length zero.

2.2.  Root Identifier ($)

Syntax: root-identifier = "$"
Semantics: Represents the root node, produces nodelist with single root node
Example: $ applied to {"k": "v"} returns [{"k": "v"}]

2.3.  Selectors

   Selectors appear only inside child segments (Section 2.5.1) and
   descendant segments (Section 2.5.2).

   A selector produces a nodelist consisting of zero or more children of
   the input value.

   There are various kinds of selectors that produce children of
   objects, children of arrays, or children of either objects or arrays.

   selector            = name-selector /
                         wildcard-selector /
                         slice-selector /
                         index-selector /
                         filter-selector

   The syntax and semantics of each kind of selector are defined below.

2.3.1.  Name Selector

2.3.1.1.  Syntax

   A name selector '<name>' selects at most one object member value.

   In contrast to JSON, the JSONPath syntax allows strings to be
   enclosed in _single_ or _double_ quotes.

   name-selector       = string-literal

   string-literal      = %x22 *double-quoted %x22 /     ; "string"
                         %x27 *single-quoted %x27       ; 'string'

   double-quoted       = unescaped /
                         %x27      /                    ; '
                         ESC %x22  /                    ; \"
                         ESC escapable

   single-quoted       = unescaped /
                         %x22      /                    ; "
                         ESC %x27  /                    ; \'
                         ESC escapable

   ESC                 = %x5C                           ; \ backslash

   unescaped           = %x20-21 /                      ; see RFC 8259
                            ; omit 0x22 "
                         %x23-26 /
                            ; omit 0x27 '
                         %x28-5B /
                            ; omit 0x5C \
                         %x5D-D7FF /
                            ; skip surrogate code points
                         %xE000-10FFFF

   escapable           = %x62 / ; b BS backspace U+0008
                         %x66 / ; f FF form feed U+000C
                         %x6E / ; n LF line feed U+000A
                         %x72 / ; r CR carriage return U+000D
                         %x74 / ; t HT horizontal tab U+0009
                         "/"  / ; / slash (solidus) U+002F
                         "\"  / ; \ backslash (reverse solidus) U+005C
                         (%x75 hexchar) ;  uXXXX U+XXXX

   hexchar             = non-surrogate /
                         (high-surrogate "\" %x75 low-surrogate)
   non-surrogate       = ((DIGIT / "A"/"B"/"C" / "E"/"F") 3HEXDIG) /
                         ("D" %x30-37 2HEXDIG )
   high-surrogate      = "D" ("8"/"9"/"A"/"B") 2HEXDIG
   low-surrogate       = "D" ("C"/"D"/"E"/"F") 2HEXDIG

   HEXDIG              = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"

   Notes:

   *  Double-quoted strings follow the JSON string syntax (Section 7 of
      [RFC8259]); single-quoted strings follow an analogous pattern.  No
      attempt was made to improve on this syntax, so if it is desired to
      escape characters with scalar values above 0xFFFF, such as U+1F041
      ("üÅÅ", DOMINO TILE HORIZONTAL-02-02), they need to be represented
      by a pair of surrogate escapes ("\uD83C\uDC41" in this case).

   *  Alphabetic characters in quoted strings are case-insensitive in
      ABNF, so each of the hexadecimal digits within \u escapes (as
      specified in rules referenced by hexchar) can be either lowercase
      or uppercase, while the u in \u needs to be lowercase (indicated
      as %x75).

2.3.1.2.  Semantics

   A name-selector string MUST be converted to a member name M by
   removing the surrounding quotes and replacing each escape sequence
   with its equivalent Unicode character, as shown in Table 4:

   +=================+===================+=============================+
   | Escape Sequence | Unicode Character | Description                 |
   +=================+===================+=============================+
   |        \b       |       U+0008      | BS backspace                |
   +-----------------+-------------------+-----------------------------+
   |        \t       |       U+0009      | HT horizontal tab           |
   +-----------------+-------------------+-----------------------------+
   |        \n       |       U+000A      | LF line feed                |
   +-----------------+-------------------+-----------------------------+
   |        \f       |       U+000C      | FF form feed                |
   +-----------------+-------------------+-----------------------------+
   |        \r       |       U+000D      | CR carriage return          |
   +-----------------+-------------------+-----------------------------+
   |        \"       |       U+0022      | quotation mark              |
   +-----------------+-------------------+-----------------------------+
   |        \'       |       U+0027      | apostrophe                  |
   +-----------------+-------------------+-----------------------------+
   |        \/       |       U+002F      | slash (solidus)             |
   +-----------------+-------------------+-----------------------------+
   |        \\       |       U+005C      | backslash (reverse          |
   |                 |                   | solidus)                    |
   +-----------------+-------------------+-----------------------------+
   |      \uXXXX     |        see        | hexadecimal escape          |
   |                 |  Section 2.3.1.1  |                             |
   +-----------------+-------------------+-----------------------------+

                   Table 4: Escape Sequence Replacements

   Applying the name-selector to an object node selects a member value
   whose name equals the member name M or selects nothing if there is no
   such member value.  Nothing is selected from a value that is not an
   object.

   Note: Processing the name selector requires comparing the member name
   string M with member name strings in the JSON to which the selector
   is being applied.  Two strings MUST be considered equal if and only
   if they are identical sequences of Unicode scalar values.  In other
   words, normalization operations MUST NOT be applied to either the
   member name string M from the JSONPath or the member name strings in
   the JSON prior to comparison.

2.3.1.3.  Examples

   JSON:

   {
     "o": {"j j": {"k.k": 3}},
     "'": {"@": 2}
   }

   Queries:

   The examples in Table 5 show the name selector in use by child
   segments.

    +====================+=======+=======================+============+
    |       Query        |Result |      Result Paths     | Comment    |
    +====================+=======+=======================+============+
    |     $.o['j j']     |{"k.k":|     $['o']['j j']     | Named      |
    |                    |3}     |                       | value in   |
    |                    |       |                       | a nested   |
    |                    |       |                       | object     |
    +--------------------+-------+-----------------------+------------+
    | $.o['j j']['k.k']  |3      |  $['o']['j j']['k.k'] | Nesting    |
    |                    |       |                       | further    |
    |                    |       |                       | down       |
    +--------------------+-------+-----------------------+------------+
    | $.o["j j"]["k.k"]  |3      |  $['o']['j j']['k.k'] | Different  |
    |                    |       |                       | delimiter  |
    |                    |       |                       | in the     |
    |                    |       |                       | query,     |
    |                    |       |                       | unchanged  |
    |                    |       |                       | Normalized |
    |                    |       |                       | Path       |
    +--------------------+-------+-----------------------+------------+
    |    $["'"]["@"]     |2      |      $['\'']['@']     | Unusual    |
    |                    |       |                       | member     |
    |                    |       |                       | names      |
    +--------------------+-------+-----------------------+------------+

                      Table 5: Name Selector Examples

2.3.2.  Wildcard Selector

2.3.2.1.  Syntax

   The wildcard selector consists of an asterisk.

   wildcard-selector   = "*"

2.3.2.2.  Semantics

   A wildcard selector selects the nodes of all children of an object or
   array.  The order in which the children of an object appear in the
   resultant nodelist is not stipulated, since JSON objects are
   unordered.  Children of an array appear in array order in the
   resultant nodelist.

   Note that the children of an object are its member values, not its
   member names.

   The wildcard selector selects nothing from a primitive JSON value
   (that is, a number, a string, true, false, or null).

2.3.2.3.  Examples

   JSON:

   {
     "o": {"j": 1, "k": 2},
     "a": [5, 3]
   }

   Queries:

   The examples in Table 6 show the wildcard selector in use by a child
   segment.

          +========+==========+=============+===================+
          | Query  | Result   |    Result   | Comment           |
          |        |          |    Paths    |                   |
          +========+==========+=============+===================+
          |  $[*]  | {"j": 1, |    $['o']   | Object values     |
          |        | "k": 2}  |    $['a']   |                   |
          |        | [5, 3]   |             |                   |
          +--------+----------+-------------+-------------------+
          | $.o[*] | 1        | $['o']['j'] | Object values     |
          |        | 2        | $['o']['k'] |                   |
          +--------+----------+-------------+-------------------+
          | $.o[*] | 2        | $['o']['k'] | Alternative       |
          |        | 1        | $['o']['j'] | result            |
          +--------+----------+-------------+-------------------+
          | $.o[*, | 1        | $['o']['j'] | Non-deterministic |
          |   *]   | 2        | $['o']['k'] | ordering          |
          |        | 2        | $['o']['k'] |                   |
          |        | 1        | $['o']['j'] |                   |
          +--------+----------+-------------+-------------------+
          | $.a[*] | 5        |  $['a'][0]  | Array members     |
          |        | 3        |  $['a'][1]  |                   |
          +--------+----------+-------------+-------------------+

                    Table 6: Wildcard Selector Examples

   The example above with the query $.o[*, *] shows that the wildcard
   selector may produce nodelists in distinct orders each time it
   appears in the child segment when it is applied to an object node
   with two or more members (but not when it is applied to object nodes
   with fewer than two members or to array nodes).

2.3.3.  Index Selector

2.3.3.1.  Syntax

   An index selector <index> matches at most one array element value.

   index-selector      = int                        ; decimal integer

   int                 = "0" /
                         (["-"] DIGIT1 *DIGIT)      ; - optional
   DIGIT1              = %x31-39                    ; 1-9 non-zero digit

   Applying the numerical index-selector selects the corresponding
   element.  JSONPath allows it to be negative (see Section 2.3.3.2).

   To be valid, the index selector value MUST be in the I-JSON range of
   exact values (see Section 2.1).

   Notes:

   *  An index-selector is an integer (in base 10, as in JSON numbers).

   *  As in JSON numbers, the syntax does not allow octal-like integers
      with leading zeros, such as 01 or -01.

2.3.3.2.  Semantics

   A non-negative index-selector applied to an array selects an array
   element using a zero-based index.  For example, the selector 0
   selects the first, and the selector 4 selects the fifth element of a
   sufficiently long array.  Nothing is selected, and it is not an
   error, if the index lies outside the range of the array.  Nothing is
   selected from a value that is not an array.

   A negative index-selector counts from the array end backwards,
   obtaining an equivalent non-negative index-selector by adding the
   length of the array to the negative index.  For example, the selector
   -1 selects the last, and the selector -2 selects the penultimate
   element of an array with at least two elements.  As with non-negative
   indexes, it is not an error if such an element does not exist; this
   simply means that no element is selected.

2.3.3.3.  Examples

   JSON:

   ["a","b"]

   Queries:

   The examples in Table 7 show the index selector in use by a child
   segment.

    +=======+========+==============+================================+
    | Query | Result | Result Paths | Comment                        |
    +=======+========+==============+================================+
    |  $[1] | "b"    |     $[1]     | Element of array               |
    +-------+--------+--------------+--------------------------------+
    | $[-2] | "a"    |     $[0]     | Element of array, from the end |
    +-------+--------+--------------+--------------------------------+

                     Table 7: Index Selector Examples

2.3.4.  Array Slice Selector

2.3.4.1.  Syntax

   The array slice selector has the form <start>:<end>:<step>.  It
   matches elements from arrays starting at index <start> and ending at
   (but not including) <end>, while incrementing by step with a default
   of 1.

   slice-selector      = [start S] ":" S [end S] [":" [S step ]]

   start               = int       ; included in selection
   end                 = int       ; not included in selection
   step                = int       ; default: 1

   The slice selector consists of three optional decimal integers
   separated by colons.  The second colon can be omitted when the third
   integer is omitted.

   To be valid, the integers provided MUST be in the I-JSON range of
   exact values (see Section 2.1).

2.3.4.2.  Semantics

   The slice selector was inspired by the slice operator that was
   proposed for ECMAScript 4 (ES4), which was never released, and that
   of Python.

2.3.4.2.1.  Informal Introduction

   This section is informative.

   Array slicing is inspired by the behavior of the
   Array.prototype.slice method of the JavaScript language, as defined
   by the ECMA-262 standard [ECMA-262], with the addition of the step
   parameter, which is inspired by the Python slice expression.

   The array slice expression start:end:step selects elements at indices
   starting at start, incrementing by step, and ending with end (which
   is itself excluded).  So, for example, the expression 1:3 (where step
   defaults to 1) selects elements with indices 1 and 2 (in that order),
   whereas 1:5:2 selects elements with indices 1 and 3.

   When step is negative, elements are selected in reverse order.  Thus,
   for example, 5:1:-2 selects elements with indices 5 and 3 (in that
   order), and ::-1 selects all the elements of an array in reverse
   order.

   When step is 0, no elements are selected.  (This is the one case that
   differs from the behavior of Python, which raises an error in this
   case.)

   The following section specifies the behavior fully, without depending
   on JavaScript or Python behavior.

2.3.4.2.2.  Normative Semantics

   A slice expression selects a subset of the elements of the input
   array in the same order as the array or the reverse order, depending
   on the sign of the step parameter.  It selects no nodes from a node
   that is not an array.

   A slice is defined by the two slice parameters, start and end, and an
   iteration delta, step.  Each of these parameters is optional.  In the
   rest of this section, len denotes the length of the input array.

   The default value for step is 1.  The default values for start and
   end depend on the sign of step, as shown in Table 8.

                    +===========+=========+==========+
                    | Condition | start   | end      |
                    +===========+=========+==========+
                    | step >= 0 | 0       | len      |
                    +-----------+---------+----------+
                    | step < 0  | len - 1 | -len - 1 |
                    +-----------+---------+----------+

                       Table 8: Default Array Slice
                           start and end Values

   Slice expression parameters start and end are not directly usable as
   slice bounds and must first be normalized.  Normalization for this
   purpose is defined as:

   FUNCTION Normalize(i, len):
     IF i >= 0 THEN
       RETURN i
     ELSE
       RETURN len + i
     END IF

   The result of the array index expression i applied to an array of
   length len is the result of the array slicing expression Normalize(i,
   len):Normalize(i, len)+1:1.

   Slice expression parameters start and end are used to derive slice
   bounds lower and upper.  The direction of the iteration, defined by
   the sign of step, determines which of the parameters is the lower
   bound and which is the upper bound:

   FUNCTION Bounds(start, end, step, len):
     n_start = Normalize(start, len)
     n_end = Normalize(end, len)

     IF step >= 0 THEN
       lower = MIN(MAX(n_start, 0), len)
       upper = MIN(MAX(n_end, 0), len)
     ELSE
       upper = MIN(MAX(n_start, -1), len-1)
       lower = MIN(MAX(n_end, -1), len-1)
     END IF

     RETURN (lower, upper)

   The slice expression selects elements with indices between the lower
   and upper bounds.  In the following pseudocode, a(i) is the i+1th
   element of the array a (i.e., a(0) is the first element, a(1) the
   second, and so forth).

   IF step > 0 THEN

     i = lower
     WHILE i < upper:
       SELECT a(i)
       i = i + step
     END WHILE

   ELSE if step < 0 THEN

     i = upper
     WHILE lower < i:
       SELECT a(i)
       i = i + step
     END WHILE

   END IF

   When step = 0, no elements are selected, and the result array is
   empty.

2.3.4.3.  Examples

   JSON:

   ["a", "b", "c", "d", "e", "f", "g"]

   Queries:

   The examples in Table 9 show the array slice selector in use by a
   child segment.

                +===========+========+========+==========+
                |   Query   | Result | Result | Comment  |
                |           |        | Paths  |          |
                +===========+========+========+==========+
                |   $[1:3]  | "b"    |  $[1]  | Slice    |
                |           | "c"    |  $[2]  | with     |
                |           |        |        | default  |
                |           |        |        | step     |
                +-----------+--------+--------+----------+
                |   $[5:]   | "f"    |  $[5]  | Slice    |
                |           | "g"    |  $[6]  | with no  |
                |           |        |        | end      |
                |           |        |        | index    |
                +-----------+--------+--------+----------+
                |  $[1:5:2] | "b"    |  $[1]  | Slice    |
                |           | "d"    |  $[3]  | with     |
                |           |        |        | step 2   |
                +-----------+--------+--------+----------+
                | $[5:1:-2] | "f"    |  $[5]  | Slice    |
                |           | "d"    |  $[3]  | with     |
                |           |        |        | negative |
                |           |        |        | step     |
                +-----------+--------+--------+----------+
                |  $[::-1]  | "g"    |  $[6]  | Slice in |
                |           | "f"    |  $[5]  | reverse  |
                |           | "e"    |  $[4]  | order    |
                |           | "d"    |  $[3]  |          |
                |           | "c"    |  $[2]  |          |
                |           | "b"    |  $[1]  |          |
                |           | "a"    |  $[0]  |          |
                +-----------+--------+--------+----------+

                  Table 9: Array Slice Selector Examples

2.3.5.  Filter Selector

   Filter selectors are used to iterate over the elements or members of
   structured values, i.e., JSON arrays and objects.  The structured
   values are identified in the nodelist offered by the child or
   descendant segment using the filter selector.

   For each iteration (element/member), a logical expression (the
   _filter expression_) is evaluated, which decides whether the node of
   the element/member is selected.  (While a logical expression
   evaluates to what mathematically is a Boolean value, this
   specification uses the term _logical_ to maintain a distinction from
   the Boolean values that JSON can represent.)

   During the iteration process, the filter expression receives the node
   of each array element or object member value of the structured value
   being filtered; this element or member value is then known as the
   _current node_.

   The current node can be used as the start of one or more JSONPath
   queries in subexpressions of the filter expression, notated via the
   current-node-identifier @. Each JSONPath query can be used either for
   testing existence of a result of the query, for obtaining a specific
   JSON value resulting from that query that can then be used in a
   comparison, or as a _function argument_.

   Filter selectors may use function extensions, which are covered in
   Section 2.4.  Within the logical expression for a filter selector,
   function expressions can be used to operate on nodelists and values.
   The set of available functions is extensible, with a number of
   functions predefined (see Section 2.4) and the ability to register
   further functions provided by the "Function Extensions" subregistry
   (Section 3.2).  When a function is defined, it is given a unique
   name, and its return value and each of its parameters are given a
   _declared type_. The type system is limited in scope; its purpose is
   to express restrictions that, without functions, are implicit in the
   grammar of filter expressions.  The type system also guides
   conversions (Section 2.4.2) that mimic the way different kinds of
   expressions are handled in the grammar when function expressions are
   not in use.

2.3.5.1.  Syntax

   The filter selector has the form ?<logical-expr>.

   filter-selector     = "?" S logical-expr

   As the filter expression is composed of constituents free of side
   effects, the order of evaluation does not need to be (and is not)
   defined.  Similarly, for conjunction (&&) and disjunction (||)
   (defined later), both a short-circuiting and a fully evaluating
   implementation will lead to the same result; both implementation
   strategies are therefore valid.

   The current node is accessible via the current node identifier @.
   This identifier addresses the current node of the filter-selector
   that is directly enclosing the identifier.  Note: Within nested
   filter-selectors, there is no syntax to address the current node of
   any other than the directly enclosing filter-selector (i.e., of
   filter-selectors enclosing the filter-selector that is directly
   enclosing the identifier).

   Logical expressions offer the usual Boolean operators (|| for OR, &&
   for AND, and ! for NOT).  They have the normal semantics of Boolean
   algebra and obey its laws (for example, see [BOOLEAN-LAWS]).
   Parentheses MAY be used within logical-expr for grouping.

   It is not required that logical-expr consist of a parenthesized
   expression (which was required in [JSONPath-orig]), although it can
   be, and the semantics are the same as without the parentheses.

   logical-expr        = logical-or-expr
   logical-or-expr     = logical-and-expr *(S "||" S logical-and-expr)
                           ; disjunction
                           ; binds less tightly than conjunction
   logical-and-expr    = basic-expr *(S "&&" S basic-expr)
                           ; conjunction
                           ; binds more tightly than disjunction

   basic-expr          = paren-expr /
                         comparison-expr /
                         test-expr

   paren-expr          = [logical-not-op S] "(" S logical-expr S ")"
                                           ; parenthesized expression
   logical-not-op      = "!"               ; logical NOT operator

   A test expression either tests the existence of a node designated by
   an embedded query (see Section 2.3.5.2.1) or tests the result of a
   function expression (see Section 2.4).  In the latter case, if the
   function's declared result type is LogicalType (see Section 2.4.1),
   it tests whether the result is LogicalTrue; if the function's
   declared result type is NodesType, it tests whether the result is
   non-empty.  If the function's declared result type is ValueType, its
   use in a test expression is not well-typed (see Section 2.4.3).

   test-expr           = [logical-not-op S]
                         (filter-query / ; existence/non-existence
                          function-expr) ; LogicalType or NodesType
   filter-query        = rel-query / jsonpath-query
   rel-query           = current-node-identifier segments
   current-node-identifier = "@"

   Comparison expressions are available for comparisons between
   primitive values (that is, numbers, strings, true, false, and null).
   These can be obtained via literal values; singular queries, each of
   which selects at most one node, the value of which is then used; or
   function expressions (see Section 2.4) of type ValueType.

   comparison-expr     = comparable S comparison-op S comparable
   literal             = number / string-literal /
                         true / false / null
   comparable          = literal /
                         singular-query / ; singular query value
                         function-expr    ; ValueType
   comparison-op       = "==" / "!=" /
                         "<=" / ">=" /
                         "<"  / ">"

   singular-query      = rel-singular-query / abs-singular-query
   rel-singular-query  = current-node-identifier singular-query-segments
   abs-singular-query  = root-identifier singular-query-segments
   singular-query-segments = *(S (name-segment / index-segment))
   name-segment        = ("[" name-selector "]") /
                         ("." member-name-shorthand)
   index-segment       = "[" index-selector "]"

   Literals can be notated in the way that is usual for JSON (with the
   extension that strings can use single-quote delimiters).

   Note: Alphabetic characters in quoted strings are case-insensitive in
   ABNF, so within a floating point number, the ABNF expression "e" can
   be either the character 'e' or 'E'.

   true, false, and null are lowercase only (case-sensitive).

   number              = (int / "-0") [ frac ] [ exp ] ; decimal number
   frac                = "." 1*DIGIT                  ; decimal fraction
   exp                 = "e" [ "-" / "+" ] 1*DIGIT    ; decimal exponent
   true                = %x74.72.75.65                ; true
   false               = %x66.61.6c.73.65             ; false
   null                = %x6e.75.6c.6c                ; null

   Table 10 lists filter expression operators in order of precedence
   from highest (binds most tightly) to lowest (binds least tightly).

            +============+======================+=============+
            | Precedence |    Operator type     |    Syntax   |
            +============+======================+=============+
            |     5      |       Grouping       |    (...)    |
            |            | Function Expressions | _name_(...) |
            +------------+----------------------+-------------+
            |     4      |     Logical NOT      |      !      |
            +------------+----------------------+-------------+
            |     3      |      Relations       |    == !=    |
            |            |                      |  < <= > >=  |
            +------------+----------------------+-------------+
            |     2      |     Logical AND      |      &&     |
            +------------+----------------------+-------------+
            |     1      |      Logical OR      |      ||     |
            +------------+----------------------+-------------+

              Table 10: Filter Expression Operator Precedence

2.3.5.2.  Semantics

   The filter selector works with arrays and objects exclusively.  Its
   result is a list of (_zero_, _one_, _multiple_, or _all_) their array
   elements or member values, respectively.  Applied to a primitive
   value, it selects nothing (and therefore does not contribute to the
   result of the filter selector).

   In the resultant nodelist, children of an array are ordered by their
   position in the array.  The order in which the children of an object
   (as opposed to an array) appear in the resultant nodelist is not
   stipulated, since JSON objects are unordered.

2.3.5.2.1.  Existence Tests

   A query by itself in a logical context is an existence test that
   yields true if the query selects at least one node and yields false
   if the query does not select any nodes.

   Existence tests differ from comparisons in that:

   *  They work with arbitrary relative or absolute queries (not just
      singular queries).

   *  They work with queries that select structured values.

   To examine the value of a node selected by a query, an explicit
   comparison is necessary.  For example, to test whether the node
   selected by the query @.foo has the value null, use @.foo == null
   (see Section 2.6) rather than the negated existence test !@.foo
   (which yields false if @.foo selects a node, regardless of the node's
   value).  Similarly, @.foo == false yields true only if @.foo selects
   a node and the value of that node is false.

2.3.5.2.2.  Comparisons

   The comparison operators == and < are defined first, and then these
   are used to define !=, <=, >, and >=.

   When either side of a comparison results in an empty nodelist or the
   special result Nothing (see Section 2.4.1):

   *  A comparison using the operator == yields true if and only the
      other side also results in an empty nodelist or the special result
      Nothing.

   *  A comparison using the operator < yields false.

   When any query or function expression on either side of a comparison
   results in a nodelist consisting of a single node, that side is
   replaced by the value of its node and then:

   *  A comparison using the operator == yields true if and only if the
      comparison is between:

      -  numbers expected to interoperate, as per Section 2.2 of I-JSON
         [RFC7493], that compare equal using normal mathematical
         equality,

      -  numbers, at least one of which is not expected to interoperate
         as per I-JSON, where the numbers compare equal using an
         implementation-specific equality,

      -  equal primitive values that are not numbers,

      -  equal arrays, that is, arrays of the same length where each
         element of the first array is equal to the corresponding
         element of the second array, or

      -  equal objects with no duplicate names, that is, where:

         o  both objects have the same collection of names (with no
            duplicates) and

         o  for each of those names, the values associated with the name
            by the objects are equal.

   *  A comparison using the operator < yields true if and only if the
      comparison is between values that are both numbers or both strings
      and that satisfy the comparison:

      -  numbers expected to interoperate, as per Section 2.2 of I-JSON
         [RFC7493], MUST compare using the normal mathematical ordering;
         numbers not expected to interoperate, as per I-JSON, MAY
         compare using an implementation-specific ordering,

      -  the empty string compares less than any non-empty string, and

      -  a non-empty string compares less than another non-empty string
         if and only if the first string starts with a lower Unicode
         scalar value than the second string or if both strings start
         with the same Unicode scalar value and the remainder of the
         first string compares less than the remainder of the second
         string.

   !=, <=, >, and >= are defined in terms of the other comparison
   operators.  For any a and b:

   *  The comparison a != b yields true if and only if a == b yields
      false.

   *  The comparison a <= b yields true if and only if a < b yields true
      or a == b yields true.

   *  The comparison a > b yields true if and only if b < a yields true.

   *  The comparison a >= b yields true if and only if b < a yields true
      or a == b yields true.

2.3.5.3.  Examples

   The first set of examples shows some comparison expressions and their
   result with a given JSON value as input.

   JSON:

   {
     "obj": {"x": "y"},
     "arr": [2, 3]
   }

   Comparisons:

       +========================+========+========================+
       |       Comparison       | Result |        Comment         |
       +========================+========+========================+
       | $.absent1 == $.absent2 |  true  |    Empty nodelists     |
       +------------------------+--------+------------------------+
       | $.absent1 <= $.absent2 |  true  |     == implies <=      |
       +------------------------+--------+------------------------+
       |    $.absent == 'g'     | false  |     Empty nodelist     |
       +------------------------+--------+------------------------+
       | $.absent1 != $.absent2 | false  |    Empty nodelists     |
       +------------------------+--------+------------------------+
       |    $.absent != 'g'     |  true  |     Empty nodelist     |
       +------------------------+--------+------------------------+
       |         1 <= 2         |  true  |   Numeric comparison   |
       +------------------------+--------+------------------------+
       |         1 > 2          | false  |   Numeric comparison   |
       +------------------------+--------+------------------------+
       |       13 == '13'       | false  |     Type mismatch      |
       +------------------------+--------+------------------------+
       |       'a' <= 'b'       |  true  |   String comparison    |
       +------------------------+--------+------------------------+
       |       'a' > 'b'        | false  |   String comparison    |
       +------------------------+--------+------------------------+
       |     $.obj == $.arr     | false  |     Type mismatch      |
       +------------------------+--------+------------------------+
       |     $.obj != $.arr     |  true  |     Type mismatch      |
       +------------------------+--------+------------------------+
       |     $.obj == $.obj     |  true  |   Object comparison    |
       +------------------------+--------+------------------------+
       |     $.obj != $.obj     | false  |   Object comparison    |
       +------------------------+--------+------------------------+
       |     $.arr == $.arr     |  true  |    Array comparison    |
       +------------------------+--------+------------------------+
       |     $.arr != $.arr     | false  |    Array comparison    |
       +------------------------+--------+------------------------+
       |      $.obj == 17       | false  |     Type mismatch      |
       +------------------------+--------+------------------------+
       |      $.obj != 17       |  true  |     Type mismatch      |
       +------------------------+--------+------------------------+
       |     $.obj <= $.arr     | false  | Objects and arrays do  |
       |                        |        | not offer < comparison |
       +------------------------+--------+------------------------+
       |     $.obj < $.arr      | false  | Objects and arrays do  |
       |                        |        | not offer < comparison |
       +------------------------+--------+------------------------+
       |     $.obj <= $.obj     |  true  |     == implies <=      |
       +------------------------+--------+------------------------+
       |     $.arr <= $.arr     |  true  |     == implies <=      |
       +------------------------+--------+------------------------+
       |       1 <= $.arr       | false  | Arrays do not offer <  |
       |                        |        |       comparison       |
       +------------------------+--------+------------------------+
       |       1 >= $.arr       | false  | Arrays do not offer <  |
       |                        |        |       comparison       |
       +------------------------+--------+------------------------+
       |       1 > $.arr        | false  | Arrays do not offer <  |
       |                        |        |       comparison       |
       +------------------------+--------+------------------------+
       |       1 < $.arr        | false  | Arrays do not offer <  |
       |                        |        |       comparison       |
       +------------------------+--------+------------------------+
       |      true <= true      |  true  |     == implies <=      |
       +------------------------+--------+------------------------+
       |      true > true       | false  | Booleans do not offer  |
       |                        |        |      < comparison      |
       +------------------------+--------+------------------------+

                      Table 11: Comparison Examples

   The second set of examples shows some complete JSONPath queries that
   make use of filter selectors and the results of evaluating these
   queries on a given JSON value as input.  (Note: Two of the queries
   employ function extensions; please see Sections 2.4.6 and 2.4.7 for
   details about these.)

   JSON:

   {
     "a": [3, 5, 1, 2, 4, 6,
           {"b": "j"},
           {"b": "k"},
           {"b": {}},
           {"b": "kilo"}
          ],
     "o": {"p": 1, "q": 2, "r": 3, "s": 5, "t": {"u": 6}},
     "e": "f"
   }

   Queries:

   The examples in Table 12 show the filter selector in use by a child
   segment.

   +==================+==============+=============+===================+
   |      Query       | Result       |    Result   | Comment           |
   |                  |              |    Paths    |                   |
   +==================+==============+=============+===================+
   |   $.a[?@.b ==    | {"b":        |  $['a'][9]  | Member value      |
   |     'kilo']      | "kilo"}      |             | comparison        |
   +------------------+--------------+-------------+-------------------+
   |   $.a[?(@.b ==   | {"b":        |  $['a'][9]  | Equivalent query  |
   |     'kilo')]     | "kilo"}      |             | with enclosing    |
   |                  |              |             | parentheses       |
   +------------------+--------------+-------------+-------------------+
   |   $.a[?@>3.5]    | 5            |  $['a'][1]  | Array value       |
   |                  | 4            |  $['a'][4]  | comparison        |
   |                  | 6            |  $['a'][5]  |                   |
   +------------------+--------------+-------------+-------------------+
   |    $.a[?@.b]     | {"b": "j"}   |  $['a'][6]  | Array value       |
   |                  | {"b": "k"}   |  $['a'][7]  | existence         |
   |                  | {"b": {}}    |  $['a'][8]  |                   |
   |                  | {"b":        |  $['a'][9]  |                   |
   |                  | "kilo"}      |             |                   |
   +------------------+--------------+-------------+-------------------+
   |     $[?@.*]      | [3, 5, 1,    |    $['a']   | Existence of non- |
   |                  | 2, 4, 6,     |    $['o']   | singular queries  |
   |                  | {"b": "j"},  |             |                   |
   |                  | {"b": "k"},  |             |                   |
   |                  | {"b": {}},   |             |                   |
   |                  | {"b":        |             |                   |
   |                  | "kilo"}]     |             |                   |
   |                  | {"p": 1,     |             |                   |
   |                  | "q": 2,      |             |                   |
   |                  | "r": 3,      |             |                   |
   |                  | "s": 5,      |             |                   |
   |                  | "t": {"u":   |             |                   |
   |                  | 6}}          |             |                   |
   +------------------+--------------+-------------+-------------------+
   |   $[?@[?@.b]]    | [3, 5, 1,    |    $['a']   | Nested filters    |
   |                  | 2, 4, 6,     |             |                   |
   |                  | {"b": "j"},  |             |                   |
   |                  | {"b": "k"},  |             |                   |
   |                  | {"b": {}},   |             |                   |
   |                  | {"b":        |             |                   |
   |                  | "kilo"}]     |             |                   |
   +------------------+--------------+-------------+-------------------+
   | $.o[?@<3, ?@<3]  | 1            | $['o']['p'] | Non-deterministic |
   |                  | 2            | $['o']['q'] | ordering          |
   |                  | 2            | $['o']['q'] |                   |
   |                  | 1            | $['o']['p'] |                   |
   +------------------+--------------+-------------+-------------------+
   | $.a[?@<2 || @.b  | 1            |  $['a'][2]  | Array value       |
   |     == "k"]      | {"b": "k"}   |  $['a'][7]  | logical OR        |
   +------------------+--------------+-------------+-------------------+
   | $.a[?match(@.b,  | {"b": "j"}   |  $['a'][6]  | Array value       |
   |     "[jk]")]     | {"b": "k"}   |  $['a'][7]  | regular           |
   |                  |              |             | expression match  |
   +------------------+--------------+-------------+-------------------+
   | $.a[?search(@.b, | {"b": "j"}   |  $['a'][6]  | Array value       |
   |     "[jk]")]     | {"b": "k"}   |  $['a'][7]  | regular           |
   |                  | {"b":        |  $['a'][9]  | expression search |
   |                  | "kilo"}      |             |                   |
   +------------------+--------------+-------------+-------------------+
   | $.o[?@>1 && @<4] | 2            | $['o']['q'] | Object value      |
   |                  | 3            | $['o']['r'] | logical AND       |
   +------------------+--------------+-------------+-------------------+
   | $.o[?@>1 && @<4] | 3            | $['o']['r'] | Alternative       |
   |                  | 2            | $['o']['q'] | result            |
   +------------------+--------------+-------------+-------------------+
   | $.o[?@.u || @.x] | {"u": 6}     | $['o']['t'] | Object value      |
   |                  |              |             | logical OR        |
   +------------------+--------------+-------------+-------------------+
   | $.a[?@.b == $.x] | 3            |  $['a'][0]  | Comparison of     |
   |                  | 5            |  $['a'][1]  | queries with no   |
   |                  | 1            |  $['a'][2]  | values            |
   |                  | 2            |  $['a'][3]  |                   |
   |                  | 4            |  $['a'][4]  |                   |
   |                  | 6            |  $['a'][5]  |                   |
   +------------------+--------------+-------------+-------------------+
   |   $.a[?@ == @]   | 3            |  $['a'][0]  | Comparisons of    |
   |                  | 5            |  $['a'][1]  | primitive and of  |
   |                  | 1            |  $['a'][2]  | structured values |
   |                  | 2            |  $['a'][3]  |                   |
   |                  | 4            |  $['a'][4]  |                   |
   |                  | 6            |  $['a'][5]  |                   |
   |                  | {"b": "j"}   |  $['a'][6]  |                   |
   |                  | {"b": "k"}   |  $['a'][7]  |                   |
   |                  | {"b": {}}    |  $['a'][8]  |                   |
   |                  | {"b":        |  $['a'][9]  |                   |
   |                  | "kilo"}      |             |                   |
   +------------------+--------------+-------------+-------------------+

                     Table 12: Filter Selector Examples

   The example above with the query $.o[?@<3, ?@<3] shows that a filter
   selector may produce nodelists in distinct orders each time it
   appears in the child segment.

2.4.  Function Extensions

   Beyond the filter expression functionality defined in the preceding
   subsections, JSONPath defines an extension point that can be used to
   add filter expression functionality: "Function Extensions".

   This section defines the extension point and some function extensions
   that use this extension point.  While these mechanisms are designed
   to use the extension point, they are an integral part of the JSONPath
   specification and are expected to be implemented like any other
   integral part of this specification.

   A function extension defines a registered name (see Section 3.2) that
   can be applied to a sequence of zero or more arguments, producing a
   result.  Each registered function name is unique.

   A function extension MUST be defined such that its evaluation is free
   of side effects, i.e., all possible orders of evaluation and choices
   of short-circuiting or full evaluation of an expression containing it
   MUST lead to the same result.  (Note: Memoization or logging are not
   side effects in this sense as they are visible at the implementation
   level only -- they do not influence the result of the evaluation.)

   function-name       = function-name-first *function-name-char
   function-name-first = LCALPHA
   function-name-char  = function-name-first / "_" / DIGIT
   LCALPHA             = %x61-7A  ; "a".."z"

   function-expr       = function-name "(" S [function-argument
                            *(S "," S function-argument)] S ")"
   function-argument   = literal /
                         filter-query / ; (includes singular-query)
                         logical-expr /
                         function-expr

   Any function expressions in a query must be well-formed (by
   conforming to the above ABNF) and well-typed; otherwise, the JSONPath
   implementation MUST raise an error (see Section 2.1).  To define
   which function expressions are well-typed, a type system is first
   introduced.

2.4.1.  Type System for Function Expressions

   Each parameter and the result of a function extension must have a
   declared type.

   Declared types enable checking a JSONPath query for well-typedness
   independent of any query argument the JSONPath query is applied to.

   Table 13 defines the available types in terms of the instances they
   contain.

               +=============+=============================+
               | Type        | Instances                   |
               +=============+=============================+
               | ValueType   | JSON values or Nothing      |
               +-------------+-----------------------------+
               | LogicalType | LogicalTrue or LogicalFalse |
               +-------------+-----------------------------+
               | NodesType   | Nodelists                   |
               +-------------+-----------------------------+

                  Table 13: Function Extension Type System

   Notes:

   *  The only instances that can be directly represented in JSONPath
      syntax are certain JSON values in ValueType expressed as literals
      (which, in JSONPath, are limited to primitive values).

   *  The special result Nothing represents the absence of a JSON value
      and is distinct from any JSON value, including null.

   *  LogicalTrue and LogicalFalse are unrelated to the JSON values
      expressed by the literals true and false.

2.4.2.  Type Conversion

   Just as queries can be used in logical expressions by testing for the
   existence of at least one node (Section 2.3.5.2.1), a function
   expression of declared type NodesType can be used as a function
   argument for a parameter of declared type LogicalType, with the
   equivalent conversion rule:

   *  If the nodelist contains one or more nodes, the conversion result
      is LogicalTrue.

   *  If the nodelist is empty, the conversion result is LogicalFalse.

   Notes:

   *  Extraction of a value from a nodelist can be performed in several
      ways, so an implicit conversion from NodesType to ValueType may be
      surprising and has therefore not been defined.

   *  A function expression with a declared type of NodesType can
      indirectly be used as an argument for a parameter of declared type
      ValueType by wrapping the expression in a call to a function
      extension, such as value() (see Section 2.4.8), that takes a
      parameter of type NodesType and returns a result of type
      ValueType.

   The well-typedness of function expressions can now be defined in
   terms of this type system.

2.4.3.  Well-Typedness of Function Expressions

   For a function expression to be well-typed:

   1.  Its declared type must be well-typed in the context in which it
       occurs.

       As per the grammar, a function expression can occur in three
       different immediate contexts, which lead to the following
       conditions for well-typedness:

       As a test-expr in a logical expression:
          The function's declared result type is LogicalType or (giving
          rise to conversion as per Section 2.4.2) NodesType.

       As a comparable in a comparison:
          The function's declared result type is ValueType.

       As a function-argument in another function expression:
          The function's declared result type fulfills the following
          rules for the corresponding parameter of the enclosing
          function.

   2.  Its arguments must be well-typed for the declared type of the
       corresponding parameters.

       The arguments of the function expression are well-typed when each
       argument of the function can be used for the declared type of the
       corresponding parameter, according to one of the following
       conditions:

       *  When the argument is a function expression with the same
          declared result type as the declared type of the parameter.

       *  When the declared type of the parameter is LogicalType and the
          argument is one of the following:

          -  A function expression with declared result type NodesType.
             In this case, the argument is converted to LogicalType as
             per Section 2.4.2.

          -  A logical-expr that is not a function expression.

       *  When the declared type of the parameter is NodesType and the
          argument is a query (which includes singular query).

       *  When the declared type of the parameter is ValueType and the
          argument is one of the following:

          -  A value expressed as a literal.

          -  A singular query.  In this case:

             o  If the query results in a nodelist consisting of a
                single node, the argument is the value of the node.

             o  If the query results in an empty nodelist, the argument
                is the special result Nothing.

2.4.4.  length() Function Extension

   Parameters:
      1.  ValueType

   Result:  ValueType (unsigned integer or Nothing)

   The length() function extension provides a way to compute the length
   of a value and make that available for further processing in the
   filter expression:

   $[?length(@.authors) >= 5]

   Its only argument is an instance of ValueType (possibly taken from a
   singular query, as in the example above).  The result is also an
   instance of ValueType: an unsigned integer or the special result
   Nothing.

   *  If the argument value is a string, the result is the number of
      Unicode scalar values in the string.

   *  If the argument value is an array, the result is the number of
      elements in the array.

   *  If the argument value is an object, the result is the number of
      members in the object.

   *  For any other argument value, the result is the special result
      Nothing.

2.4.5.  count() Function Extension

   Parameters:
      1.  NodesType

   Result:  ValueType (unsigned integer)

   The count() function extension provides a way to obtain the number of
   nodes in a nodelist and make that available for further processing in
   the filter expression:

   $[?count(@.*.author) >= 5]

   Its only argument is a nodelist.  The result is a value (an unsigned
   integer) that gives the number of nodes in the nodelist.

   Notes:

   *  There is no deduplication of the nodelist.

   *  The number of nodes in the nodelist is counted independent of
      their values or any children they may have, e.g., the count of a
      non-empty singular nodelist such as count(@) is always 1.

2.4.6.  match() Function Extension

   Parameters:
      1.  ValueType (string)

      2.  ValueType (string conforming to [RFC9485])

   Result:  LogicalType

   The match() function extension provides a way to check whether (the
   entirety of; see Section 2.4.7) a given string matches a given
   regular expression, which is in the form described in [RFC9485].

   $[?match(@.date, "1974-05-..")]

   Its arguments are instances of ValueType (possibly taken from a
   singular query, as for the first argument in the example above).  If
   the first argument is not a string or the second argument is not a
   string conforming to [RFC9485], the result is LogicalFalse.
   Otherwise, the string that is the first argument is matched against
   the I-Regexp contained in the string that is the second argument; the
   result is LogicalTrue if the string matches the I-Regexp and is
   LogicalFalse otherwise.

2.4.7.  search() Function Extension

   Parameters:
      1.  ValueType (string)

      2.  ValueType (string conforming to [RFC9485])

   Result:  LogicalType

   The search() function extension provides a way to check whether a
   given string contains a substring that matches a given regular
   expression, which is in the form described in [RFC9485].

   $[?search(@.author, "[BR]ob")]

   Its arguments are instances of ValueType (possibly taken from a
   singular query, as for the first argument in the example above).  If
   the first argument is not a string or the second argument is not a
   string conforming to [RFC9485], the result is LogicalFalse.
   Otherwise, the string that is the first argument is searched for a
   substring that matches the I-Regexp contained in the string that is
   the second argument; the result is LogicalTrue if at least one such
   substring exists and is LogicalFalse otherwise.

2.4.8.  value() Function Extension

   Parameters:
      1.  NodesType

   Result:  ValueType

   The value() function extension provides a way to convert an instance
   of NodesType to a value and make that available for further
   processing in the filter expression:

   $[?value(@..color) == "red"]

   Its only argument is an instance of NodesType (possibly taken from a
   filter-query, as in the example above).  The result is an instance of
   ValueType.

   *  If the argument contains a single node, the result is the value of
      the node.

   *  If the argument is the empty nodelist or contains multiple nodes,
      the result is Nothing.

   Note: A singular query may be used anywhere where a ValueType is
   expected, so there is no need to use the value() function extension
   with a singular query.

2.4.9.  Examples

    +======================+==========================================+
    |        Query         | Comment                                  |
    +======================+==========================================+
    |  $[?length(@) < 3]   | well-typed                               |
    +----------------------+------------------------------------------+
    | $[?length(@.*) < 3]  | not well-typed since @.* is a non-       |
    |                      | singular query                           |
    +----------------------+------------------------------------------+
    | $[?count(@.*) == 1]  | well-typed                               |
    +----------------------+------------------------------------------+
    |  $[?count(1) == 1]   | not well-typed since 1 is not a query or |
    |                      | function expression                      |
    +----------------------+------------------------------------------+
    |  $[?count(foo(@.*))  | well-typed, where foo() is a function    |
    |        == 1]         | extension with a parameter of type       |
    |                      | NodesType and result type NodesType      |
    +----------------------+------------------------------------------+
    | $[?match(@.timezone, | well-typed                               |
    |    'Europe/.*')]     |                                          |
    +----------------------+------------------------------------------+
    | $[?match(@.timezone, | not well-typed as LogicalType may not be |
    |   'Europe/.*') ==    | used in comparisons                      |
    |        true]         |                                          |
    +----------------------+------------------------------------------+
    |  $[?value(@..color)  | well-typed                               |
    |      == "red"]       |                                          |
    +----------------------+------------------------------------------+
    | $[?value(@..color)]  | not well-typed as ValueType may not be   |
    |                      | used in a test expression                |
    +----------------------+------------------------------------------+
    |     $[?bar(@.a)]     | well-typed for any function bar() with a |
    |                      | parameter of any declared type and       |
    |                      | result type LogicalType                  |
    +----------------------+------------------------------------------+
    |     $[?bnl(@.*)]     | well-typed for any function bnl() with a |
    |                      | parameter of declared type NodesType or  |
    |                      | LogicalType and result type LogicalType  |
    +----------------------+------------------------------------------+
    |    $[?blt(1==1)]     | well-typed, where blt() is a function    |
    |                      | with a parameter of declared type        |
    |                      | LogicalType and result type LogicalType  |
    +----------------------+------------------------------------------+
    |      $[?blt(1)]      | not well-typed for the same function     |
    |                      | blt(), as 1 is not a query, logical-     |
    |                      | expr, or function expression             |
    +----------------------+------------------------------------------+
    |      $[?bal(1)]      | well-typed, where bal() is a function    |
    |                      | with a parameter of declared type        |
    |                      | ValueType and result type LogicalType    |
    +----------------------+------------------------------------------+

                   Table 14: Function Expression Examples

2.5.  Segments

   For each node in an input nodelist, segments apply one or more
   selectors to the node and concatenate the results of each selector
   into per-input-node nodelists, which are then concatenated in the
   order of the input nodelist to form a single segment result nodelist.

   It turns out that the more segments there are in a query, the greater
   the depth in the input value of the nodes of the resultant nodelist:

   *  A query with N segments, where N >= 0, produces a nodelist
      consisting of nodes at depth in the input value of N or greater.

   *  A query with N segments, where N >= 0, all of which are child
      segments (Section 2.5.1), produces a nodelist consisting of nodes
      precisely at depth N in the input value.

   There are two kinds of segments: child segments and descendant
   segments.

   segment             = child-segment / descendant-segment

   The syntax and semantics of each kind of segment are defined below.

2.5.1.  Child Segment

2.5.1.1.  Syntax

   The child segment consists of a non-empty, comma-separated sequence
   of selectors enclosed in square brackets.

   Shorthand notations are also provided for when there is a single
   wildcard or name selector.

   child-segment       = bracketed-selection /
                         ("."
                          (wildcard-selector /
                           member-name-shorthand))

   bracketed-selection = "[" S selector *(S "," S selector) S "]"

   member-name-shorthand = name-first *name-char
   name-first          = ALPHA /
                         "_"   /
                         %x80-D7FF /
                            ; skip surrogate code points
                         %xE000-10FFFF
   name-char           = name-first / DIGIT

   DIGIT               = %x30-39              ; 0-9
   ALPHA               = %x41-5A / %x61-7A    ; A-Z / a-z

   .*, a child-segment directly built from a wildcard-selector, is
   shorthand for [*].

   .<member-name>, a child-segment built from a member-name-shorthand,
   is shorthand for ['<member-name>'].  Note: This can only be used with
   member names that are composed of certain characters, as specified in
   the ABNF rule member-name-shorthand.  Thus, for example, $.foo.bar is
   shorthand for $['foo']['bar'] (but not for $['foo.bar']).

2.5.1.2.  Semantics

   A child segment contains a sequence of selectors, each of which
   selects zero or more children of the input value.

   Selectors of different kinds may be combined within a single child
   segment.

   For each node in the input nodelist, the resulting nodelist of a
   child segment is the concatenation of the nodelists from each of its
   selectors in the order that the selectors appear in the list.  Note:
   Any node matched by more than one selector is kept as many times in
   the nodelist.

   Where a selector can produce a nodelist in more than one possible
   order, each occurrence of the selector in the child segment may
   produce a nodelist in a distinct order.

   In summary, a child segment drills down one more level into the
   structure of the input value.

2.5.1.3.  Examples

   JSON:

   ["a", "b", "c", "d", "e", "f", "g"]

   Queries:

                 +========+========+========+============+
                 | Query  | Result | Result | Comment    |
                 |        |        | Paths  |            |
                 +========+========+========+============+
                 |  $[0,  | "a"    |  $[0]  | Indices    |
                 |   3]   | "d"    |  $[3]  |            |
                 +--------+--------+--------+------------+
                 | $[0:2, | "a"    |  $[0]  | Slice and  |
                 |   5]   | "b"    |  $[1]  | index      |
                 |        | "f"    |  $[5]  |            |
                 +--------+--------+--------+------------+
                 |  $[0,  | "a"    |  $[0]  | Duplicated |
                 |   0]   | "a"    |  $[0]  | entries    |
                 +--------+--------+--------+------------+

                      Table 15: Child Segment Examples

2.5.2.  Descendant Segment

2.5.2.1.  Syntax

   The descendant segment consists of a double dot .. followed by a
   child segment (using bracket notation).

   Shorthand notations are also provided that correspond to the
   shorthand forms of the child segment.

   descendant-segment  = ".." (bracketed-selection /
                               wildcard-selector /
                               member-name-shorthand)

   ..*, the descendant-segment directly built from a wildcard-selector,
   is shorthand for ..[*].

   ..<member-name>, a descendant-segment built from a member-name-
   shorthand, is shorthand for ..['<member-name>'].  Note: As with the
   similar shorthand of a child-segment, this can only be used with
   member names that are composed of certain characters, as specified in
   the ABNF rule member-name-shorthand.

   Note: On its own, .. is not a valid segment.

2.5.2.2.  Semantics

   A descendant segment produces zero or more descendants of an input
   value.

   For each node in the input nodelist, a descendant selector visits the
   input node and each of its descendants such that:

   *  nodes of any array are visited in array order, and

   *  nodes are visited before their descendants.

   The order in which the children of an object are visited is not
   stipulated, since JSON objects are unordered.

   Suppose the descendant segment is of the form ..[<selectors>] (after
   converting any shorthand form to bracket notation), and the nodes, in
   the order visited, are D1, ..., Dn (where n >= 1).  Note: D1 is the
   input value.

   For each i such that 1 <= i <= n, the nodelist Ri is defined to be a
   result of applying the child segment [<selectors>] to the node Di.

   For each node in the input nodelist, the result of the descendant
   segment is the concatenation of R1, ..., Rn (in that order).  These
   results are then concatenated in input nodelist order to form the
   result of the segment.

   In summary, a descendant segment drills down one or more levels into
   the structure of each input value.

2.5.2.3.  Examples

   JSON:

   {
     "o": {"j": 1, "k": 2},
     "a": [5, 3, [{"j": 4}, {"k": 6}]]
   }

   Queries:

   (Note that the fourth example can be expressed in two equivalent
   queries, shown in Table 16 in one table row instead of two almost-
   identical rows.)

   +==========+================+===================+===================+
   |  Query   | Result         |    Result Paths   | Comment           |
   +==========+================+===================+===================+
   |   $..j   | 1              |    $['o']['j']    | Object values     |
   |          | 4              | $['a'][2][0]['j'] |                   |
   +----------+----------------+-------------------+-------------------+
   |   $..j   | 4              | $['a'][2][0]['j'] | Alternative       |
   |          | 1              |    $['o']['j']    | result            |
   +----------+----------------+-------------------+-------------------+
   |  $..[0]  | 5              |     $['a'][0]     | Array values      |
   |          | {"j": 4}       |    $['a'][2][0]   |                   |
   +----------+----------------+-------------------+-------------------+
   |  $..[*]  | {"j": 1,       |       $['o']      | All values        |
   |    or    | "k": 2}        |       $['a']      |                   |
   |   $..*   | [5, 3,         |    $['o']['j']    |                   |
   |          | [{"j": 4},     |    $['o']['k']    |                   |
   |          | {"k": 6}]]     |     $['a'][0]     |                   |
   |          | 1              |     $['a'][1]     |                   |
   |          | 2              |     $['a'][2]     |                   |
   |          | 5              |    $['a'][2][0]   |                   |
   |          | 3              |    $['a'][2][1]   |                   |
   |          | [{"j": 4},     | $['a'][2][0]['j'] |                   |
   |          | {"k": 6}]      | $['a'][2][1]['k'] |                   |
   |          | {"j": 4}       |                   |                   |
   |          | {"k": 6}       |                   |                   |
   |          | 4              |                   |                   |
   |          | 6              |                   |                   |
   +----------+----------------+-------------------+-------------------+
   |   $..o   | {"j": 1,       |       $['o']      | Input value is    |
   |          | "k": 2}        |                   | visited           |
   +----------+----------------+-------------------+-------------------+
   | $.o..[*, | 1              |    $['o']['j']    | Non-deterministic |
   |    *]    | 2              |    $['o']['k']    | ordering          |
   |          | 2              |    $['o']['k']    |                   |
   |          | 1              |    $['o']['j']    |                   |
   +----------+----------------+-------------------+-------------------+
   | $.a..[0, | 5              |     $['a'][0]     | Multiple segments |
   |    1]    | 3              |     $['a'][1]     |                   |
   |          | {"j": 4}       |    $['a'][2][0]   |                   |
   |          | {"k": 6}       |    $['a'][2][1]   |                   |
   +----------+----------------+-------------------+-------------------+

                   Table 16: Descendant Segment Examples

   Note: The ordering of the results for the $..[*] and $..* examples
   above is not guaranteed, except that:

   *  {"j": 1, "k": 2} must appear before 1 and 2,

   *  [5, 3, [{"j": 4}, {"k": 6}]] must appear before 5, 3, and [{"j":
      4}, {"k": 6}],

   *  5 must appear before 3, which must appear before [{"j": 4}, {"k":
      6}],

   *  5 and 3 must appear before {"j": 4}, 4, {"k": 6}, and 6,

   *  [{"j": 4}, {"k": 6}] must appear before {"j": 4} and {"k": 6},

   *  {"j": 4} must appear before {"k": 6},

   *  {"k": 6} must appear before 4, and

   *  4 must appear before 6.

   The example above with the query $.o..[*, *] shows that a selector
   may produce nodelists in distinct orders each time it appears in the
   descendant segment.

   The example above with the query $.a..[0, 1] shows that the child
   segment [0, 1] is applied to each node in turn (rather than the nodes
   being visited once per selector, which is the case for some JSONPath
   implementations that do not conform to this specification).

2.6.  Semantics of null

   Note: JSON null is treated the same as any other JSON value, i.e., it
   is not taken to mean "undefined" or "missing".

2.6.1.  Examples

   JSON:

   {"a": null, "b": [null], "c": [{}], "null": 1}

   Queries:

   +=================+========+===========+===========================+
   |      Query      | Result |   Result  | Comment                   |
   |                 |        |   Paths   |                           |
   +=================+========+===========+===========================+
   |       $.a       | null   |   $['a']  | Object value              |
   +-----------------+--------+-----------+---------------------------+
   |      $.a[0]     |        |           | null used as array        |
   +-----------------+--------+-----------+---------------------------+
   |      $.a.d      |        |           | null used as object       |
   +-----------------+--------+-----------+---------------------------+
   |      $.b[0]     | null   | $['b'][0] | Array value               |
   +-----------------+--------+-----------+---------------------------+
   |      $.b[*]     | null   | $['b'][0] | Array value               |
   +-----------------+--------+-----------+---------------------------+
   |     $.b[?@]     | null   | $['b'][0] | Existence                 |
   +-----------------+--------+-----------+---------------------------+
   |  $.b[?@==null]  | null   | $['b'][0] | Comparison                |
   +-----------------+--------+-----------+---------------------------+
   | $.c[?@.d==null] |        |           | Comparison with "missing" |
   |                 |        |           | value                     |
   +-----------------+--------+-----------+---------------------------+
   |      $.null     | 1      | $['null'] | Not JSON null at all,     |
   |                 |        |           | just a member name string |
   +-----------------+--------+-----------+---------------------------+

           Table 17: Examples Involving (or Not Involving) null

2.7.  Normalized Paths

   A Normalized Path is a unique representation of the location of a
   node in a value that uniquely identifies the node in the value.
   Specifically, a Normalized Path is a JSONPath query with restricted
   syntax (defined below), e.g., $['book'][3], which when applied to the
   value, results in a nodelist consisting of just the node identified
   by the Normalized Path.  Note: A Normalized Path represents the
   identity of a node _in a specific value_. There is precisely one
   Normalized Path identifying any particular node in a value.

   A nodelist may be represented compactly in JSON as an array of
   strings, where the strings are Normalized Paths.

   Normalized Paths provide a predictable format that simplifies testing
   and post-processing of nodelists, e.g., to remove duplicate nodes.
   Normalized Paths are used in this document as result paths in
   examples.

   Normalized Paths use the canonical bracket notation, rather than dot
   notation.

   Single quotes are used in Normalized Paths to delimit string member
   names.  This reduces the number of characters that need escaping when
   Normalized Paths appear in strings delimited by double quotes, e.g.,
   in JSON texts.

   Certain characters are escaped in Normalized Paths in one and only
   one way; all other characters are unescaped.

      |  Note: Normalized Paths are singular queries, but not all
      |  singular queries are Normalized Paths.  For example, $[-3] is a
      |  singular query but is not a Normalized Path.  The Normalized
      |  Path equivalent to $[-3] would have an index equal to the array
      |  length minus 3.  (The array length must be at least 3 if $[-3]
      |  is to identify a node.)

   normalized-path      = root-identifier *(normal-index-segment)
   normal-index-segment = "[" normal-selector "]"
   normal-selector      = normal-name-selector / normal-index-selector
   normal-name-selector = %x27 *normal-single-quoted %x27 ; 'string'
   normal-single-quoted = normal-unescaped /
                          ESC normal-escapable
   normal-unescaped     =    ; omit %x0-1F control codes
                          %x20-26 /
                             ; omit 0x27 '
                          %x28-5B /
                             ; omit 0x5C \
                          %x5D-D7FF /
                             ; skip surrogate code points
                          %xE000-10FFFF

   normal-escapable     = %x62 / ; b BS backspace U+0008
                          %x66 / ; f FF form feed U+000C
                          %x6E / ; n LF line feed U+000A
                          %x72 / ; r CR carriage return U+000D
                          %x74 / ; t HT horizontal tab U+0009
                          "'" /  ; ' apostrophe U+0027
                          "\" /  ; \ backslash (reverse solidus) U+005C
                          (%x75 normal-hexchar)
                                          ; certain values u00xx U+00XX
   normal-hexchar       = "0" "0"
                          (
                             ("0" %x30-37) / ; "00"-"07"
                                ; omit U+0008-U+000A BS HT LF
                             ("0" %x62) /    ; "0b"
                                ; omit U+000C-U+000D FF CR
                             ("0" %x65-66) / ; "0e"-"0f"
                             ("1" normal-HEXDIG)
                          )
   normal-HEXDIG        = DIGIT / %x61-66    ; "0"-"9", "a"-"f"
   normal-index-selector = "0" / (DIGIT1 *DIGIT)
                           ; non-negative decimal integer

   Since there can only be one Normalized Path identifying a given node,
   the syntax stipulates which characters are escaped and which are not.
   So the definition of normal-hexchar is designed for hex escaping of
   characters that are not straightforwardly printable, for example,
   U+000B LINE TABULATION, but for which no standard JSON escape, such
   as \n, is available.

2.7.1.  Examples

       +=============+=================+==========================+
       |     Path    | Normalized Path | Comment                  |
       +=============+=================+==========================+
       |     $.a     |      $['a']     | Object value             |
       +-------------+-----------------+--------------------------+
       |     $[1]    |       $[1]      | Array index              |
       +-------------+-----------------+--------------------------+
       |    $[-3]    |       $[2]      | Negative array index for |
       |             |                 | an array of length 5     |
       +-------------+-----------------+--------------------------+
       |  $.a.b[1:2] |  $['a']['b'][1] | Nested structure         |
       +-------------+-----------------+--------------------------+
       | $["\u000B"] |   $['\u000b']   | Unicode escape           |
       +-------------+-----------------+--------------------------+
       | $["\u0061"] |      $['a']     | Unicode character        |
       +-------------+-----------------+--------------------------+

                    Table 18: Normalized Path Examples

Appendix A.  Collected ABNF Grammars

   This appendix collects the ABNF grammar from the ABNF passages used
   throughout the document.

   Figure 2 contains the collected ABNF grammar that defines the syntax
   of a JSONPath query.

   jsonpath-query      = root-identifier segments
   segments            = *(S segment)

   B                   = %x20 /    ; Space
                         %x09 /    ; Horizontal tab
                         %x0A /    ; Line feed or New line
                         %x0D      ; Carriage return
   S                   = *B        ; optional blank space
   root-identifier     = "$"
   selector            = name-selector /
                         wildcard-selector /
                         slice-selector /
                         index-selector /
                         filter-selector
   name-selector       = string-literal

   string-literal      = %x22 *double-quoted %x22 /     ; "string"
                         %x27 *single-quoted %x27       ; 'string'

   double-quoted       = unescaped /
                         %x27      /                    ; '
                         ESC %x22  /                    ; \"
                         ESC escapable

   single-quoted       = unescaped /
                         %x22      /                    ; "
                         ESC %x27  /                    ; \'
                         ESC escapable

   ESC                 = %x5C                           ; \ backslash

   unescaped           = %x20-21 /                      ; see RFC 8259
                            ; omit 0x22 "
                         %x23-26 /
                            ; omit 0x27 '
                         %x28-5B /
                            ; omit 0x5C \
                         %x5D-D7FF /
                            ; skip surrogate code points
                         %xE000-10FFFF

   escapable           = %x62 / ; b BS backspace U+0008
                         %x66 / ; f FF form feed U+000C
                         %x6E / ; n LF line feed U+000A
                         %x72 / ; r CR carriage return U+000D
                         %x74 / ; t HT horizontal tab U+0009
                         "/"  / ; / slash (solidus) U+002F
                         "\"  / ; \ backslash (reverse solidus) U+005C
                         (%x75 hexchar) ;  uXXXX U+XXXX

   hexchar             = non-surrogate /
                         (high-surrogate "\" %x75 low-surrogate)
   non-surrogate       = ((DIGIT / "A"/"B"/"C" / "E"/"F") 3HEXDIG) /
                         ("D" %x30-37 2HEXDIG )
   high-surrogate      = "D" ("8"/"9"/"A"/"B") 2HEXDIG
   low-surrogate       = "D" ("C"/"D"/"E"/"F") 2HEXDIG

   HEXDIG              = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
   wildcard-selector   = "*"
   index-selector      = int                        ; decimal integer

   int                 = "0" /
                         (["-"] DIGIT1 *DIGIT)      ; - optional
   DIGIT1              = %x31-39                    ; 1-9 non-zero digit
   slice-selector      = [start S] ":" S [end S] [":" [S step ]]

   start               = int       ; included in selection
   end                 = int       ; not included in selection
   step                = int       ; default: 1
   filter-selector     = "?" S logical-expr
   logical-expr        = logical-or-expr
   logical-or-expr     = logical-and-expr *(S "||" S logical-and-expr)
                           ; disjunction
                           ; binds less tightly than conjunction
   logical-and-expr    = basic-expr *(S "&&" S basic-expr)
                           ; conjunction
                           ; binds more tightly than disjunction

   basic-expr          = paren-expr /
                         comparison-expr /
                         test-expr

   paren-expr          = [logical-not-op S] "(" S logical-expr S ")"
                                           ; parenthesized expression
   logical-not-op      = "!"               ; logical NOT operator
   test-expr           = [logical-not-op S]
                         (filter-query / ; existence/non-existence
                          function-expr) ; LogicalType or NodesType
   filter-query        = rel-query / jsonpath-query
   rel-query           = current-node-identifier segments
   current-node-identifier = "@"
   comparison-expr     = comparable S comparison-op S comparable
   literal             = number / string-literal /
                         true / false / null
   comparable          = literal /
                         singular-query / ; singular query value
                         function-expr    ; ValueType
   comparison-op       = "==" / "!=" /
                         "<=" / ">=" /
                         "<"  / ">"

   singular-query      = rel-singular-query / abs-singular-query
   rel-singular-query  = current-node-identifier singular-query-segments
   abs-singular-query  = root-identifier singular-query-segments
   singular-query-segments = *(S (name-segment / index-segment))
   name-segment        = ("[" name-selector "]") /
                         ("." member-name-shorthand)
   index-segment       = "[" index-selector "]"
   number              = (int / "-0") [ frac ] [ exp ] ; decimal number
   frac                = "." 1*DIGIT                  ; decimal fraction
   exp                 = "e" [ "-" / "+" ] 1*DIGIT    ; decimal exponent
   true                = %x74.72.75.65                ; true
   false               = %x66.61.6c.73.65             ; false
   null                = %x6e.75.6c.6c                ; null
   function-name       = function-name-first *function-name-char
   function-name-first = LCALPHA
   function-name-char  = function-name-first / "_" / DIGIT
   LCALPHA             = %x61-7A  ; "a".."z"

   function-expr       = function-name "(" S [function-argument
                            *(S "," S function-argument)] S ")"
   function-argument   = literal /
                         filter-query / ; (includes singular-query)
                         logical-expr /
                         function-expr
   segment             = child-segment / descendant-segment
   child-segment       = bracketed-selection /
                         ("."
                          (wildcard-selector /
                           member-name-shorthand))

   bracketed-selection = "[" S selector *(S "," S selector) S "]"

   member-name-shorthand = name-first *name-char
   name-first          = ALPHA /
                         "_"   /
                         %x80-D7FF /
                            ; skip surrogate code points
                         %xE000-10FFFF
   name-char           = name-first / DIGIT

   DIGIT               = %x30-39              ; 0-9
   ALPHA               = %x41-5A / %x61-7A    ; A-Z / a-z
   descendant-segment  = ".." (bracketed-selection /
                               wildcard-selector /
                               member-name-shorthand)

                Figure 2: Collected ABNF of JSONPath Queries

   Figure 3 contains the collected ABNF grammar that defines the syntax
   of a JSONPath Normalized Path while also using the rules root-
   identifier, ESC, DIGIT, and DIGIT1 from Figure 2.

   normalized-path      = root-identifier *(normal-index-segment)
   normal-index-segment = "[" normal-selector "]"
   normal-selector      = normal-name-selector / normal-index-selector
   normal-name-selector = %x27 *normal-single-quoted %x27 ; 'string'
   normal-single-quoted = normal-unescaped /
                          ESC normal-escapable
   normal-unescaped     =    ; omit %x0-1F control codes
                          %x20-26 /
                             ; omit 0x27 '
                          %x28-5B /
                             ; omit 0x5C \
                          %x5D-D7FF /
                             ; skip surrogate code points
                          %xE000-10FFFF

   normal-escapable     = %x62 / ; b BS backspace U+0008
                          %x66 / ; f FF form feed U+000C
                          %x6E / ; n LF line feed U+000A
                          %x72 / ; r CR carriage return U+000D
                          %x74 / ; t HT horizontal tab U+0009
                          "'" /  ; ' apostrophe U+0027
                          "\" /  ; \ backslash (reverse solidus) U+005C
                          (%x75 normal-hexchar)
                                          ; certain values u00xx U+00XX
   normal-hexchar       = "0" "0"
                          (
                             ("0" %x30-37) / ; "00"-"07"
                                ; omit U+0008-U+000A BS HT LF
                             ("0" %x62) /    ; "0b"
                                ; omit U+000C-U+000D FF CR
                             ("0" %x65-66) / ; "0e"-"0f"
                             ("1" normal-HEXDIG)
                          )
   normal-HEXDIG        = DIGIT / %x61-66    ; "0"-"9", "a"-"f"
   normal-index-selector = "0" / (DIGIT1 *DIGIT)
                           ; non-negative decimal integer

           Figure 3: Collected ABNF of JSONPath Normalized Paths
